#!/usr/bin/env python3

import sys, os, hashlib

'''
 Templates for files used by the simulation and model checking engines:
   Makefile
   properties.ad[sb]
   mc_lib.gpr
 These files all depend on the set of observers used to verify properties

 (c) 2022 Maxime Perrotin, European Space Agency
 part of the TASTE project, see https://taste.tools
'''

Makefile = '''# Generated by TASTE - do not edit (run taste-process-observers.py to update)

all: modelcheck

modelcheck:{adb} mcsrc/modelcheck.adb mcsrc/properties.adb mcsrc/mc.adb mcsrc/mc.ads observers/gser.ads
	ADA_PROJECT_PATH=~/.local/share/gpr:${{ADA_PROJECT_PATH}} gprbuild -p -P mc

libsimulator.so:{adb} mcsrc/modelcheck.adb mcsrc/properties.adb mcsrc/mc.adb mcsrc/mc.ads observers/gser.ads
	#  make a library version for python interfacing
	ADA_PROJECT_PATH=~/.local/share/gpr:${{ADA_PROJECT_PATH}} gprbuild -p -P mc_lib.gpr

simu: libsimulator.so
	taste-interactive-simulator

{build}

observers/gser.ads:
	# generate Ada package to print asn1 values
	taste-asn1-gser --raw -o observers --module gser observer.asn {datamodels}

clean:
	ADA_PROJECT_PATH=~/.local/share/gpr:${{ADA_PROJECT_PATH}} gprclean -P mc_lib || :
	ADA_PROJECT_PATH=~/.local/share/gpr:${{ADA_PROJECT_PATH}} gprclean -P mc || :
	rm -rf observers/*.ad? *.ali *.[cho] *.so *.ad[bs] *.cfg obj

.PHONY: simu clean all modelcheck
'''

Makefile_Adb = " observers/{name}.adb"

Makefile_Build = '''observers/{name}.adb: observers/{name}.pr
	cd observers && opengeode --toAda {name}.pr && \
	asn1scc  -Ada -typePrefix asn1scc -equal  --target allboards observer.asn {name}_datamodel.asn  && \
	mv src/{name}_datamodel.ad? .
'''

Makefile_Datamodel = '''observers/{name}_datamodel.asn'''

MC_Lib = '''with "share/gpr/simulator.gpr";
with "asn1_iterators";

library project mc_lib is

   for Library_Name use "simulator";
   for Library_Dir use ".";
   for Library_Kind use "dynamic";

   for Library_Standalone use "encapsulated";
   for Library_Options use ("-lrt", "-lm");
   for Interfaces use (
      "properties.ads",
      "gser.ads",
      {interface}
      "mc.ads"
   );

   for Source_Dirs use (
       "mcsrc",
       "../dataview/iterators",
       "observers"
   );

   for Object_Dir use "obj";
   package Compiler is
      for Default_Switches ("Ada") use (
         "-Wall",
         "-Wextra",
         "-Wcast-align"
      );
   end Compiler;
end mc_lib;
'''

MC_Lib_Interface = '''"{name}.ads",
      "{name}_datamodel.ads",
      "{name}_ri.ads",'''

Properties_Ads = '''--  Add the data model of all observers to form the full state
{withes}

with Simulation_Dataview; use Simulation_Dataview;

with adaasn1rtl; use adaasn1rtl;
with GSER;

package Properties is

    --  The state stored in the graph is defined here, putting together the
    --  state of the TASTE system and the state of the observers
    type State_With_Observers is tagged
        record
            User_State        : asn1sccSystem_State;
            {fields}
        end record;

   --  Define the functions of the tagged type
   --  Later the User state part can be a PER-encoded string to save space
   --  When this happens, the following functions need to be update to do
   --  The encoding/decoding on the fly
   function Application_State (Full_State : State_With_Observers)
       return asn1SccSystem_State is (Full_State.User_State);

   procedure Update_State (Full_State        : in out State_With_Observers;
                           Application_State : asn1SccSystem_State);

   -- Return a GSER string of the state, useful to print or to compute hash
   function State_To_String (Full_State : State_With_Observers) return String is
       (GSER.Image (Full_State.User_State){gser});


   procedure Print_Full_State (Full_State : State_With_Observers);

   function Full_State_Init return State_With_Observers is
       (User_State        => asn1sccSystem_State_Init{init});

   procedure My_Properties (Full_State : in out State_With_Observers;
                            Event      : in out asn1sccObservable_Event;
                            Id         : out Natural;
                            Success    : out Boolean);

end Properties;
'''

Properties_Ads_With = '''with {name};
with {name}_Datamodel;
'''

Properties_Ads_Field = '''{name}_State : {name}_Datamodel.asn1Scc{name}_Context;
'''

Properties_Ads_Init = '''{name}_State => {name}.Ctxt'''

Properties_Ads_GSER_Image = ''' & GSER.Image (Full_State.{name}_State)'''

Properties_Adb = '''with Text_IO; use Text_IO;
with iterators_types;
use iterators_types;

{withes}

with GSER;

package body Properties is

   procedure Update_State (Full_State        : in out State_With_Observers;
                           Application_State : asn1SccSystem_State) is
   begin
       Full_State.User_State := Application_State;
   end Update_State;

   procedure Print_Full_State (Full_State : State_With_Observers) is
   begin
       Put_Line (State_To_String (Full_State));
   end Print_Full_State;

   procedure My_Properties (Full_State : in out State_With_Observers;
                            Event      : in out asn1sccObservable_Event;
                            Id         : out Natural;
                            Success    : out Boolean) is
       Observer_State_Status : asn1SccObserver_State_Kind;
   begin
       Id := 0;
       {runs}
   end;
end Properties;
'''

Properties_Adb_With = '''with {name};
with {name}_Datamodel; use {name}_Datamodel;
'''

# Pattern for the execution of one observer
Properties_Adb_Run = '''-- Restore the state of the observer, and execute it
       {name}.Ctxt := Full_State.{name}_State;
       --  Put_Line ("[OBS] Context set to: " & GSER.Image ({name}.Ctxt));

       Observer_State_Status := {name}.Observe (Full_State.User_State, Event);
       --  Read the modified state from the observer
       Event                 := {name}.Event;
       Full_State.User_State := {name}.St;
       Full_State.{name}_State := {name}.Ctxt;
       --  Simple stop condition:
       Success := (Observer_State_Status = asn1SccError_State);
       if Success then
          Put_Line ("Stop condition found");
          return;
       end if;
       Id := Id + 1;
'''

def main():
    observers = []
    for entry in os.scandir("observers/"):
        if entry.name.endswith(".pr"):
            observers.append(entry.name[:-3])
    if observers:
        print("[-] Found the following observers:" , ", ".join(observers))
    else:
        print("[-] No observers found, generating generic templates")


    Makefile_Adbs = "".join(Makefile_Adb.format(name=o) for o in observers)
    Makefile_Builds = "".join(Makefile_Build.format(name=o) for o in observers)
    Makefile_Datamodels = " ".join(Makefile_Datamodel.format(name=o) for o in observers)
    MC_Lib_Interfaces = "\n      ".join(MC_Lib_Interface.format(name=o) for o in observers)
    Properties_Ads_Withes = "".join(Properties_Ads_With.format(name=o.title()) for o in observers)
    Properties_Ads_Fields = "".join(Properties_Ads_Field.format(name=o.title()) for o in observers)
    if observers:
        Properties_Ads_Inits = ",\n        " + ",\n        ".join(Properties_Ads_Init.format(name=o.title()) for o in observers)
    else:
        Properties_Ads_Inits = ""
    Properties_Ads_GSER_Images = "".join(Properties_Ads_GSER_Image.format(name=o.title()) for o in observers)
    Properties_Adb_Withes = "".join(Properties_Adb_With.format(name=o.title()) for o in observers)
    Properties_Adb_Runs = "".join(Properties_Adb_Run.format(name=o.title()) for o in observers)

    Makefile_String = Makefile.format(adb=Makefile_Adbs, build=Makefile_Builds, datamodels=Makefile_Datamodels)
    MC_Lib_String = MC_Lib.format(interface=MC_Lib_Interfaces)
    Properties_Ads_String = Properties_Ads.format(withes=Properties_Ads_Withes,
            fields=Properties_Ads_Fields,
            init=Properties_Ads_Inits,
            gser=Properties_Ads_GSER_Images)
    Properties_Adb_String = Properties_Adb.format(withes=Properties_Adb_Withes,
            runs=Properties_Adb_Runs)

    md5 = hashlib.md5(Makefile_String.encode('utf-8')).hexdigest()
    try:
        old = hashlib.md5(open('Makefile.Simulation','rb').read()).hexdigest()
    except FileNotFoundError:
        old = ""
    if old != md5:
        print("[-] Generating Makefile.Simulation")
        with open("Makefile.Simulation", "w") as f:
            f.write(Makefile_String)
    else:
        print("[-] No change in Makefile.Simulation, ignoring")

    md5 = hashlib.md5(MC_Lib_String.encode('utf-8')).hexdigest()
    try:
        old = hashlib.md5(open('mc_lib.gpr','rb').read()).hexdigest()
    except FileNotFoundError:
        old = ""
    if old != md5:
        print("[-] Generating mc_lib.gpr")
        with open("mc_lib.gpr", "w") as f:
            f.write(MC_Lib_String)
    else:
        print("[-] No change in mc_lib.gpr, ignoring")

    md5 = hashlib.md5(Properties_Ads_String.encode('utf-8')).hexdigest()
    try:
        old = hashlib.md5(open('mcsrc/properties.ads','rb').read()).hexdigest()
    except FileNotFoundError:
        old = ""
    if old != md5:
        print("[-] Generating properties.ads")
        with open("mcsrc/properties.ads", "w") as f:
            f.write(Properties_Ads_String)
    else:
        print("[-] No change in properties.ads, ignoring")

    md5 = hashlib.md5(Properties_Adb_String.encode('utf-8')).hexdigest()
    try:
        old = hashlib.md5(open('mcsrc/properties.adb','rb').read()).hexdigest()
    except FileNotFoundError:
        old = ""
    if old != md5:
        print("[-] Generating properties.adb")
        with open("mcsrc/properties.adb", "w") as f:
            f.write(Properties_Adb_String)
    else:
        print("[-] No change in properties.adb, ignoring")

    print("[-] Done. Now you can run `make -f Makefile.Simulation [modelcheck|simu]`")

main()
